---
layout: default
title: ANNIS Query Language - AQL
category: ANNIS
description: "Introduction to the ANNIS Query Language (AQL) which is used by ANNIS as its query language."
redirect_from: "/aql.html"
--- 

<div class="page-header">
<h1>ANNIS Query Language - AQL </h1>
</div>

<h2>Nodes and Edges</h2>
<p>AQL is based on the concept of searching for node elements and edges between them. A search is formulated by defining each token, non-terminal node or annotation being searched for as an element. An element can be a token (simply text between quotes: <code><span class="s">&quot;dogs&quot;</span></code> or else <code><span class="nv">tok</span>=<span class="s">&quot;dogs&quot;</span></code>) or an attribute-value pair (such as <code><span class="nv">tok</span>=<span class="s">&quot;dogs&quot;</span></code>, or optionally with a namespace: <code><span class="nv">tiger:cat</span>=<span class="s">&quot;PP&quot;</span></code>). Note that different corpora can have completely different annotation names and values - these are not specified by ANNIS. Underspecified tokens or nodes in general may be specified using <code><span class="nv">tok</span></code> and <code><span class="nv">node</span></code> respectively.</p>
<p>
Once all elements are declared, relations between the elements (or edges) are specified which must hold between them. The elements are referred back to serially using variable numbers, and linguistic operators bind them together, e.g. <code>#1 &gt; #2</code> meaning the first element dominates the second in a tree or graph. Operators define the possible overlap and adjacency relations between annotation spans, as well as recursive hierarchical relations between nodes. Some operators also allow specific labes to be specified in addition to the operator (see the operator list below).
</p>
<p>
The following example, a query searching for German sentences with topicalized objects (i.e. with the word order object-verb-subject), illustrates these ideas in practice as a complete example: </p>
<div class="table-responsive">
<table class="table">
<tr>
<th>Query</th><th>Explanation</th>
</tr>
<tr>
	<td>
<div class="highlight"><pre><span class="nv">node</span> <span class="o">&amp;</span> <span class="nv">pos</span>=<span class="s">&quot;VVFIN&quot;</span> <span class="o">&amp;</span> <span class="nv">cat</span>=<span class="s">&quot;S&quot;</span> <span class="o">&amp;</span> <span class="nv">node</span> <span class="o">&amp;</span>
<span class="nl">#3</span> <span class="o">&gt;</span>[<span class="nv">tiger:func</span>=<span class="s">&quot;OA&quot;</span>] <span class="nl">#1</span> <span class="o">&amp;</span>
<span class="nl">#3</span> <span class="o">&gt;</span>[<span class="nv">tiger:func</span>=<span class="s">&quot;SB&quot;</span>] <span class="nl">#4</span> <span class="o">&amp;</span>
<span class="nl">#3</span> <span class="o">&gt; </span><span class="nl">#2</span> <span class="o">&amp;</span>
<span class="nl">#1</span> <span class="o">.*</span> <span class="nl">#2</span> <span class="o">&amp;</span>
<span class="nl">#2</span> <span class="o">.*</span> <span class="nl">#4</span>
</pre></div>
	</td>
	<td>
	<pre>two nodes are defined, a finite verb and a sentence node (S)
S dominates node 1 with label OA
S dominates node 4 with label SB
S dominates (>) the verb
node 1 precedes (.*) the verb
the verb precedes (.*) node 4</pre>
	</td>
</tr>
</table>
</div>
<p><a href="https://korpling.german.hu-berlin.de/annis3/#_q=bm9kZSAmIHBvcz0iVlZGSU4iICYgY2F0PSJTIiAmIG5vZGUgJiAgCiMzID5bdGlnZXI6ZnVuYz0iT0EiXSAjMSAmCiMzID5bdGlnZXI6ZnVuYz0iU0IiXSAjNCAmCiMzID4gIzIgJgojMSAuKiAjMiAmCiMyIC4qICM0&_c=cGNjMg&cl=5&cr=5&s=0&l=10" target="_blank">
Try out this query in the pcc2 corpus in ANNIS3
</a></p>
<h2>Shortcuts</h2>
<p>
Starting in ANNIS 3.1.0, you can also use shortcuts to define the relations between query nodes. You can specify the
operator that applies between two nodes directly between those nodes. For example, the following two queries are equivalent:
</p>
<div class="highlight"><pre><span class="nv">cat</span>=<span class="s">&quot;NP&quot;</span> <span class="o">&amp;</span> <span class="nv">cat</span>=<span class="s">&quot;PP&quot;</span> <span class="o">&amp;</span> <span class="nl">#1</span> <span class="o">&gt; </span><span class="nl">#2</span>
</pre></div>
<p><strong>or</strong></p>
<div class="highlight"><pre><span class="nv">cat</span>=<span class="s">&quot;NP&quot;</span> <span class="o">&gt; </span><span class="nv">cat</span>=<span class="s">&quot;PP&quot;</span>
</pre></div>
<p>
Specifying the dominance operator <code>&gt;</code> directly between the NP and PP nodes works the same as declaring the two nodes and
then stating that the dominance relationshop hold between the first node (#1) and the second one (#2).
</p>


<h2>Naming nodes</h2>
<p>For complex queries in which the same nodes are involved in multiple relations, it may be easier to name nodes explicitly, rather than using the #1, #2, ... number notation.
Node names are given to nodes when they are defined and are placed before the '#' sing. The following query illustrates this mechanism:</p>

<div class="table-responsive">
<table class="table">
<tr>
<th>Query</th><th>Explanation</th>
</tr>
<tr>
	<td>
<div class="highlight"><pre><span class="nv">NP</span><span class="nl">#cat</span>=<span class="s">&quot;NP&quot;</span> <span class="o">&amp;</span>  
<span class="nv">PP1</span><span class="nl">#cat</span>=<span class="s">&quot;PP&quot;</span> <span class="o">. </span><span class="nv">PP2</span><span class="nl">#cat</span>=<span class="s">&quot;PP&quot;</span> <span class="o">&amp;</span>
<span class="nl">#NP</span> <span class="o">&gt; </span><span class="nl">#PP1</span> <span class="o">&amp;</span>
<span class="nl">#NP</span> <span class="o">&gt; </span><span class="nl">#PP2</span>
</pre></div>
	</td>
	<td>
	<pre>a nominal phrase which we will call 'NP' 
two consecutive prepositional phrases named PP1 and PP2 
the NP node dominates PP1
the same NP node also dominates PP2 </pre>
	</td>
</tr>
</table>
</div>
<p><a href="https://korpling.german.hu-berlin.de/annis3/#_q=TlAjY2F0PSJOUCIgJiAgClBQMSNjYXQ9IlBQIiAuIFBQMiNjYXQ9IlBQIiAmCiNOUCA-ICNQUDEgJgojTlAgPiAjUFAy&_c=R1VN&cl=5&cr=5&s=0&l=10" target="_blank">
Try out this query in the GUM corpus in ANNIS3
</a></p>


<h2>Metadata</h2>
<p>
To specify metadata conditions which must apply to matches, add key-value pairs preceded by the reserved prefix <code>meta::</code>. Metadata may apply to corpora, sub-corpora, or individual documents within a corpus. For example, the following query finds sequences of two consecutive adverbs in sports documents (Genre="Sport"):
</p>
<div class="table-responsive">
<table class="table">
<tr>
<th>Query</th><th>Explanation</th>
</tr>
<tr>
	<td>
<div class="highlight"><pre><span class="nv">pos</span>=<span class="s">&quot;ADV&quot;</span> <span class="o">&amp;</span> <span class="nv">pos</span>=<span class="s">&quot;ADV&quot;</span> <span class="o">&amp;</span>
<span class="nl">#1</span> <span class="o">. </span><span class="nl">#2</span> <span class="o">&amp;</span>
<span class="nv">meta</span>::<span class="nv">Genre</span>=<span class="s">&quot;Sport&quot;</span>
</pre></div>
	</td>
	<td>
	<pre>two adverb tags
adverb 1 precedes adverb 2 directly
the metadatum Genre must have the value "Sport"</pre>
	</td>
</tr>
</table>
</div>
<br>
<p><a href="https://korpling.german.hu-berlin.de/annis3/#_q=cG9zPSJBRFYiICYgcG9zPSJBRFYiICYKIzEgLiAjMiAmCm1ldGE6OkdlbnJlPSJTcG9ydCI&_c=cGNjMg&cl=5&cr=5&s=0&l=10" target="_blank">
Try out this query in the pcc2 corpus in ANNIS
</a></p>



<h2>Unary Operators</h2>
<p>Two operators refer to only one matching element, instead of specifying a relationship between two elements: <tt>tokenarity</tt> and <tt>arity</tt>.
The <tt>tokenarity</tt> operator specifies how many tokens should be covered by the matching element, whereas the <tt>arity</tt> operator determines the amount of directly dominated children the matched node should have.
For example, the following query searches for nominal phrases that dominate exactly 4 nodes:
</p>
<div class="table-responsive">
<table class="table">
<tr>
<th>Query</th><th>Explanation</th>
</tr>
<tr>
	<td>
<div class="highlight"><pre><span class="nv">cat</span>=<span class="s">&quot;NP&quot;</span> 
<span class="o">&amp;</span> <span class="nl">#1</span>:<span class="nv">arity</span>=4
</pre></div>
	</td>
	<td>
	<pre>a syntactic category 'NP' for 'nominal phrase'
this node should have exactly 4 children </pre>
	</td>
</tr>
</table>
</div>
<br>
<p><a href="https://korpling.german.hu-berlin.de/annis3/#_q=Y2F0PSJOUCIgJiAjMTphcml0eT00&_c=cGNjMg&cl=5&cr=5&s=0&l=10" target="_blank">
Try out this query in the pcc2 corpus in ANNIS
</a></p>


<h2>Query Builder</h2>
<p>
 In order to facilitate the formulation of complex queries, a graphical query builder allows users to define their search in a graph. This reflects the nodes and edges in the query directly but gives a more intuitive view of the elements and relations being searched for.
 </p>
<div class="image_wrap" style="text-align:center;">
  <img src="images/annis3_querybuilder_edge.png" alt="ANNIS3 Query Builder" style="width:30%;">
  <div><strong>The Query Builder allows users to model queries as a graph</strong></div>
</div>


<h2>RegEx Support </h2>
<p>
ANNIS supports RegEx natively in all token, annotation, edge label and metadata searches. In the query builder simply select <code>~</code> instead of <code>=</code> as the comparison operator. When entering a query manually use <code>=</code> but replace the double quotes around annotation and token values with slashes, e.g. <code>lemma=/d.g/</code> finds &quot;dog&quot; and &quot;dig&quot;. </p>

<h2>Example Queries</h2>
<p>
Beginning with ANNIS 3.0.0, the possibility to include user-defined example queries within a corpus distribution has been added. The example queries can be entered
in a separate file, called example_queries.tab within the relANNIS corpus folder. For more information on how to add example queries to your corpus, see the ANNIS User Guide on the <a href="documentation.html">documentation</a> page.
</p>

<h2>Operators</h2>
<p>AQL currently includes the following operators:</p>

<div class="table-responsive">
      <table border="1" class="table">
	<tr><td height="20"><strong>Operator</strong></td>
	<td><strong>Description</strong></td>
	<td colspan="3"><strong>Illustration</strong></td>
	<td><strong>Notes</strong></td>
	</tr>
	<tr><td height="38"><code>.</code></td><td>direct precedence</td><td colspan="3"><center>
	  <strong>A B</strong>
	  </center></td><td>For non-terminal nodes, precedence is determined by the right-most and left-most terminal children. In corpora with multiple segmentations the layer on which consecutivity holds may be specified with <code>.layer</code></td></tr>
	  
	<tr><td height="38"><code>.*</code></td><td>indirect precedence</td><td colspan="3"><center><strong>A</strong> <span class="style1">x y z</span> <strong>B</strong>
	</center></td><td>For specific sizes of precedence spans, <code>.n,m</code> can be used, e.g. <code>.3,4</code> - between 3 and 4 token distance; the default maximum distance for <code>.*</code> is 50 tokens. As above, segmentation layers may be specified, e.g. <code>.layer,3,4</code></td></tr>
	<tr><td height="38"><code>^</code></td><td>directly near</td><td colspan="3"><center>
	  <strong>A B</strong> or <strong>B A</strong>
	  </center></td><td>Same as precedence, but in either order. In corpora with multiple segmentations the layer on which consecutivity holds may be specified with <code>^layer</code></td></tr>
	<tr><td height="38"><code>^*</code></td><td>indirectly near</td><td colspan="3"><center><strong>A</strong> <span class="style1">x y z</span> <strong>B</strong> or <strong>B</strong> <span class="style1">x y z</span> <strong>A</strong>
	</center></td><td>Like indirect precedence in either order.  The form <code>^n,m</code> can be used, e.g. <code>^3,4</code> - between 3 and 4 token distance; the default maximum distance for <code>^*</code> is 50 tokens. As above, segmentation layers may be specified, e.g. <code>^layer,3,4</code></td></tr>

	<tr><td height="56"><code>&gt;</code></td><td>direct dominance</td><td colspan="3"><center>
	  <strong>A</strong> <br>
	  |<br>
	  <strong>B</strong>
	  </center></td>
	<td>A specific edge type may be specified, e.g. <code>&gt;secedge</code> to find secondary edges. Edge labels are specified in brackets, e.g. <code>&gt;[func="OA"]</code> for an edge with the function 'object, accusative'</td>
	</tr>
	<tr>
	  <td height="92"><code>&gt;*</code></td>
	  <td>indirect dominance</td>
	  <td colspan="3"><center>
	    <strong>A</strong><br>
    |<br>
    ...  <br>
	    |<br>
	    <strong>B</strong>
	    </center></td>
	  <td>For specific distance of dominance, <code>&gt;n,m</code> can be used, e.g. <code>&gt;3,4</code> - dominates with 3 to 4 edges distance</td>
	</tr>
	<tr><td height="38"><code>_=_</code></td><td>identical coverage</td><td colspan="3"><center><strong>A<br>B</strong></center></td>
	<td>Applies when two annotations cover the exact same span of tokens </td>
	</tr>
	<tr>
	  <td height="38"><code>_i_</code></td>
	  <td>inclusion</td>
	  <td colspan="3"><center>
	    <strong>AAA<br>
B	    </strong>
	  </center></td>
	  <td>Applies when one annotation covers a span identical to or larger than another </td>
	</tr>
	<tr>
	  <td height="38"><code>_o_</code></td>
	  <td>overlap</td>
	  <td colspan="3"><center>
	    <strong>AAA&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;BBB</strong><strong></strong>
	  </center></td>
	  <td>For overlap only on the left or right side, use <code>_ol_</code> and <code>_or_</code> respectively </td>
	</tr>
	<tr>
	  <td height="38"><code>_l_</code></td>
	  <td>left aligned</td>
		  <td width="15">&nbsp;</td>
	  <td colspan="2" valign="top">	      <div align="left"><strong>A</strong><strong>AA<br>
             BB&nbsp;</strong>
	        </div></td>
	  <td>Both elements span an area beginning with the same token </td>
	</tr>
		<tr>
		  <td height="38"><code>_r_</code></td>
		  <td>right aligned</td>
		  <td colspan="2" valign="top">	        <div align="right"><strong>AA<br>
	          BBB
		        </strong><strong></strong>
		        </div></td>
		  <td width="26">&nbsp;</td>
		  <td>Both elements span an area ending with the same token </td>
		</tr>
				<tr>
		  <td height="38"><code>==</code></td>
		  <td>value identity</td>
		  <td colspan="3"><center>
		      <strong>A = B</strong>
		  </center></td>
		  <td>The value of the annotation or token A is identical to that of B (this operator does not bind, i.e. the nodes must be connected by some other criteria too)</td>
		  </tr>
		  	<tr>
		  <td height="38"><code>!=</code></td>
		  <td>value difference</td>
		  <td colspan="3"><center>
		      <strong>A &ne; B</strong>
		  </center></td>
		  <td>The value of the annotation or token A is different from B (this operator does not bind, i.e. the nodes must be connected by some other criteria too)</td>
		  </tr>

	<tr>
	  <td height="38"><code>-&gt;LABEL</code></td>
	  <td>labeled pointing relation</td>
	  <td colspan="3"><center>
<table cellpadding="0" cellspacing="0">
<tr><td colspan="4" align="center">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>LABEL</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td style="padding: 0in 0in 0in 0in; border-left: solid windowtext 1.0pt; border-top: solid windowtext 1.0pt">&nbsp;&nbsp;&nbsp;&nbsp;</td><td style="padding: 0in 0in 0in 0in; border-right: solid windowtext 1.0pt; border-top: solid windowtext 1.0pt">&nbsp;&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td colspan="2" align="center">V</td><td style="border-right: solid windowtext 1.0pt">&nbsp;</td><td align="center">&nbsp;</td></tr>
<tr><td colspan="2" align="center"><strong>A</strong></td><td colspan="2" align="center">&nbsp;<strong>B</strong></td>
</table>
	  </center></td><td>A labeled, directed relationship between two elements. Annotations can be specified with
<code>-&gt;LABEL[annotation="VALUE"]</code>
</td>
	</tr>

		<tr>
		  <td height="38"><code>-&gt;LABEL *</code></td>
		  <td>indirect pointing relation</td>
		  <td colspan="3"><center>
<table cellpadding="0" cellspacing="0">
<tr><td colspan="6" align="center"><tt>LABEL&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;LABEL</tt></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td style="padding: 0in 0in 0in 0in; border-left: solid windowtext 1.0pt; border-top: solid windowtext 1.0pt">&nbsp;&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td style="padding: 0in 0in 0in 0in; border-top: solid windowtext 1.0pt">&nbsp;&nbsp;&nbsp;&nbsp;</td><td style="padding: 0in 0in 0in 0in; border-right: solid windowtext 1.0pt; border-top: solid windowtext 1.0pt">&nbsp;&nbsp;&nbsp;&nbsp;</td><td>&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td colspan="4" align="left">&nbsp;&nbsp;&nbsp;V</td><td style="border-right: solid windowtext 1.0pt">&nbsp;</td><td align="center">&nbsp;</td></tr>
<tr><td colspan="3" align="center"><strong>A</strong></td><td colspan="3" align="center">&nbsp;<strong>B</strong></td>
</table>

		  </center></td><td>An indirect labeled relationship between two elements. The length of the chain may be specified with
<code>-&gt;LABEL n,m</code> for relation chains of length n to m

	</td>
	</tr>


	<tr>
	  <td height="38"><code>&gt;@l</code></td>
	  <td>left-most child</td>
	  <td colspan="3"><center>
	    <strong>A</strong> <br>
/ | \<br>
<strong>B </strong><span class="style1">x y</span>
	  </center></td><td>&nbsp;</td>
	</tr>
	<tr>
	  <td height="38"><code>&gt;@r</code></td>
	  <td>right-most child</td>
	  <td colspan="3"><center>
	    <strong>A<br>
	    </strong>/ | \
        <br>
        <span class="style1">x y</span> <strong>B</strong>
	  </center></td>
	  <td>&nbsp;</td>
	</tr>
	<tr>
	  <td><code>$</code></td>
	  <td>Common parent node</td>
	  <td colspan="3"><center>
	    x<br>
	      / \<br>
	      <strong>A B</strong>
	  </center></td>
	  <td>&nbsp;</td>
	  </tr>
<tr><td><code>$*</code></td><td>Common ancestor node</td><td colspan="3"><center>x<br> |<br>
 ...<br>
  / \<br>
  <strong>A B</strong>
</center></td>
<td>&nbsp;</td></tr>

 <tr>
  <td>
  <code>#x:arity=n</code>
  </td>
  <td>
  Arity
  </td>
  <td colspan="3" align="center">
  x<br>/ | \<br>
  <b> 1 ... n</b>
  </td>
  <td>Specifies the amount of directly dominated children that the searched node has </td>
 </tr>
 <tr>
  <td valign="center">
  <code>#x:tokenarity=n</code>
  </td>
  <td valign="center">
  Tokenarity
  </td>
  <td colspan="3" align="center" valign="center">
   x<br>...<br> /  \<br>
  <b>1 ... n</b>
  </td>
  <td>Specifies the length of the span of tokens covered by the node</td>
 </tr>


  <tr>
   <td valign="center">
   <code>#x:root</code>
   </td>
   <td valign="center">
   Root
   </td>
   <td colspan="3" align="center" valign="center">
    ___<br>x<br>...
   </td>
   <td>Specifies that the node is not dominated by any other node within its namespace</td>
  </tr>
</table>
</div>
